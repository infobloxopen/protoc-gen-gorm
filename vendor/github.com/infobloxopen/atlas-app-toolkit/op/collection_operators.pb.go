// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/infobloxopen/atlas-app-toolkit/op/collection_operators.proto

/*
Package op is a generated protocol buffer package.

It is generated from these files:
	github.com/infobloxopen/atlas-app-toolkit/op/collection_operators.proto

It has these top-level messages:
	SortCriteria
	Sorting
	FieldSelection
	Field
	Filtering
	LogicalOperator
	StringCondition
	NumberCondition
	NullCondition
	Pagination
	PageInfo
*/
package op

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Order is a sort order.
type SortCriteria_Order int32

const (
	// ascending sort order
	SortCriteria_ASC SortCriteria_Order = 0
	// descending sort order
	SortCriteria_DESC SortCriteria_Order = 1
)

var SortCriteria_Order_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var SortCriteria_Order_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x SortCriteria_Order) String() string {
	return proto.EnumName(SortCriteria_Order_name, int32(x))
}
func (SortCriteria_Order) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type LogicalOperator_Type int32

const (
	LogicalOperator_AND LogicalOperator_Type = 0
	LogicalOperator_OR  LogicalOperator_Type = 1
)

var LogicalOperator_Type_name = map[int32]string{
	0: "AND",
	1: "OR",
}
var LogicalOperator_Type_value = map[string]int32{
	"AND": 0,
	"OR":  1,
}

func (x LogicalOperator_Type) String() string {
	return proto.EnumName(LogicalOperator_Type_name, int32(x))
}
func (LogicalOperator_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type StringCondition_Type int32

const (
	StringCondition_EQ    StringCondition_Type = 0
	StringCondition_MATCH StringCondition_Type = 1
)

var StringCondition_Type_name = map[int32]string{
	0: "EQ",
	1: "MATCH",
}
var StringCondition_Type_value = map[string]int32{
	"EQ":    0,
	"MATCH": 1,
}

func (x StringCondition_Type) String() string {
	return proto.EnumName(StringCondition_Type_name, int32(x))
}
func (StringCondition_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type NumberCondition_Type int32

const (
	NumberCondition_EQ NumberCondition_Type = 0
	NumberCondition_GT NumberCondition_Type = 1
	NumberCondition_GE NumberCondition_Type = 2
	NumberCondition_LT NumberCondition_Type = 3
	NumberCondition_LE NumberCondition_Type = 4
)

var NumberCondition_Type_name = map[int32]string{
	0: "EQ",
	1: "GT",
	2: "GE",
	3: "LT",
	4: "LE",
}
var NumberCondition_Type_value = map[string]int32{
	"EQ": 0,
	"GT": 1,
	"GE": 2,
	"LT": 3,
	"LE": 4,
}

func (x NumberCondition_Type) String() string {
	return proto.EnumName(NumberCondition_Type_name, int32(x))
}
func (NumberCondition_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// SortCriteria represents sort criteria
type SortCriteria struct {
	// Tag is a JSON tag.
	Tag   string             `protobuf:"bytes,1,opt,name=tag" json:"tag,omitempty"`
	Order SortCriteria_Order `protobuf:"varint,2,opt,name=order,enum=infoblox.api.SortCriteria_Order" json:"order,omitempty"`
}

func (m *SortCriteria) Reset()                    { *m = SortCriteria{} }
func (m *SortCriteria) String() string            { return proto.CompactTextString(m) }
func (*SortCriteria) ProtoMessage()               {}
func (*SortCriteria) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SortCriteria) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *SortCriteria) GetOrder() SortCriteria_Order {
	if m != nil {
		return m.Order
	}
	return SortCriteria_ASC
}

// Sorting represents list of sort criterias.
type Sorting struct {
	Criterias []*SortCriteria `protobuf:"bytes,1,rep,name=criterias" json:"criterias,omitempty"`
}

func (m *Sorting) Reset()                    { *m = Sorting{} }
func (m *Sorting) String() string            { return proto.CompactTextString(m) }
func (*Sorting) ProtoMessage()               {}
func (*Sorting) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Sorting) GetCriterias() []*SortCriteria {
	if m != nil {
		return m.Criterias
	}
	return nil
}

// FieldSelection represents a group of fields for some object.
// Main use case for if is to store information about object fields that
// need to be ratained prior to sending object as a response
type FieldSelection struct {
	Fields map[string]*Field `protobuf:"bytes,1,rep,name=fields" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FieldSelection) Reset()                    { *m = FieldSelection{} }
func (m *FieldSelection) String() string            { return proto.CompactTextString(m) }
func (*FieldSelection) ProtoMessage()               {}
func (*FieldSelection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FieldSelection) GetFields() map[string]*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// Field represents a single field for an object.
// It contains fields name and also may contain a group of sub-fields for cases
// when a fields represents some structure.
type Field struct {
	Name string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Subs map[string]*Field `protobuf:"bytes,2,rep,name=subs" json:"subs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Field) Reset()                    { *m = Field{} }
func (m *Field) String() string            { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()               {}
func (*Field) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Field) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Field) GetSubs() map[string]*Field {
	if m != nil {
		return m.Subs
	}
	return nil
}

// Filtering represents filtering expression.
// root could be either LogicalOperator or one of the supported conditions.
type Filtering struct {
	// Types that are valid to be assigned to Root:
	//	*Filtering_Operator
	//	*Filtering_StringCondition
	//	*Filtering_NumberCondition
	//	*Filtering_NullCondition
	Root isFiltering_Root `protobuf_oneof:"root"`
}

func (m *Filtering) Reset()                    { *m = Filtering{} }
func (m *Filtering) String() string            { return proto.CompactTextString(m) }
func (*Filtering) ProtoMessage()               {}
func (*Filtering) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isFiltering_Root interface {
	isFiltering_Root()
}

type Filtering_Operator struct {
	Operator *LogicalOperator `protobuf:"bytes,1,opt,name=operator,oneof"`
}
type Filtering_StringCondition struct {
	StringCondition *StringCondition `protobuf:"bytes,2,opt,name=string_condition,json=stringCondition,oneof"`
}
type Filtering_NumberCondition struct {
	NumberCondition *NumberCondition `protobuf:"bytes,3,opt,name=number_condition,json=numberCondition,oneof"`
}
type Filtering_NullCondition struct {
	NullCondition *NullCondition `protobuf:"bytes,4,opt,name=null_condition,json=nullCondition,oneof"`
}

func (*Filtering_Operator) isFiltering_Root()        {}
func (*Filtering_StringCondition) isFiltering_Root() {}
func (*Filtering_NumberCondition) isFiltering_Root() {}
func (*Filtering_NullCondition) isFiltering_Root()   {}

func (m *Filtering) GetRoot() isFiltering_Root {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Filtering) GetOperator() *LogicalOperator {
	if x, ok := m.GetRoot().(*Filtering_Operator); ok {
		return x.Operator
	}
	return nil
}

func (m *Filtering) GetStringCondition() *StringCondition {
	if x, ok := m.GetRoot().(*Filtering_StringCondition); ok {
		return x.StringCondition
	}
	return nil
}

func (m *Filtering) GetNumberCondition() *NumberCondition {
	if x, ok := m.GetRoot().(*Filtering_NumberCondition); ok {
		return x.NumberCondition
	}
	return nil
}

func (m *Filtering) GetNullCondition() *NullCondition {
	if x, ok := m.GetRoot().(*Filtering_NullCondition); ok {
		return x.NullCondition
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Filtering) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Filtering_OneofMarshaler, _Filtering_OneofUnmarshaler, _Filtering_OneofSizer, []interface{}{
		(*Filtering_Operator)(nil),
		(*Filtering_StringCondition)(nil),
		(*Filtering_NumberCondition)(nil),
		(*Filtering_NullCondition)(nil),
	}
}

func _Filtering_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Filtering)
	// root
	switch x := m.Root.(type) {
	case *Filtering_Operator:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Operator); err != nil {
			return err
		}
	case *Filtering_StringCondition:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringCondition); err != nil {
			return err
		}
	case *Filtering_NumberCondition:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NumberCondition); err != nil {
			return err
		}
	case *Filtering_NullCondition:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NullCondition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Filtering.Root has unexpected type %T", x)
	}
	return nil
}

func _Filtering_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Filtering)
	switch tag {
	case 1: // root.operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalOperator)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_Operator{msg}
		return true, err
	case 2: // root.string_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_StringCondition{msg}
		return true, err
	case 3: // root.number_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_NumberCondition{msg}
		return true, err
	case 4: // root.null_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NullCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_NullCondition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Filtering_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Filtering)
	// root
	switch x := m.Root.(type) {
	case *Filtering_Operator:
		s := proto.Size(x.Operator)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_StringCondition:
		s := proto.Size(x.StringCondition)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_NumberCondition:
		s := proto.Size(x.NumberCondition)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_NullCondition:
		s := proto.Size(x.NullCondition)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// LogicalOperator represents binary logical operator, either AND or OR depending on type.
// left and right are respectively left and right operands of the operator, could be
// either LogicalOperator or one of the supported conditions.
// is_negative is set to true if the operator is negated.
type LogicalOperator struct {
	// Types that are valid to be assigned to Left:
	//	*LogicalOperator_LeftOperator
	//	*LogicalOperator_LeftStringCondition
	//	*LogicalOperator_LeftNumberCondition
	//	*LogicalOperator_LeftNullCondition
	Left isLogicalOperator_Left `protobuf_oneof:"left"`
	// Types that are valid to be assigned to Right:
	//	*LogicalOperator_RightOperator
	//	*LogicalOperator_RightStringCondition
	//	*LogicalOperator_RightNumberCondition
	//	*LogicalOperator_RightNullCondition
	Right      isLogicalOperator_Right `protobuf_oneof:"right"`
	Type       LogicalOperator_Type    `protobuf:"varint,9,opt,name=type,enum=infoblox.api.LogicalOperator_Type" json:"type,omitempty"`
	IsNegative bool                    `protobuf:"varint,10,opt,name=is_negative,json=isNegative" json:"is_negative,omitempty"`
}

func (m *LogicalOperator) Reset()                    { *m = LogicalOperator{} }
func (m *LogicalOperator) String() string            { return proto.CompactTextString(m) }
func (*LogicalOperator) ProtoMessage()               {}
func (*LogicalOperator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isLogicalOperator_Left interface {
	isLogicalOperator_Left()
}
type isLogicalOperator_Right interface {
	isLogicalOperator_Right()
}

type LogicalOperator_LeftOperator struct {
	LeftOperator *LogicalOperator `protobuf:"bytes,1,opt,name=left_operator,json=leftOperator,oneof"`
}
type LogicalOperator_LeftStringCondition struct {
	LeftStringCondition *StringCondition `protobuf:"bytes,2,opt,name=left_string_condition,json=leftStringCondition,oneof"`
}
type LogicalOperator_LeftNumberCondition struct {
	LeftNumberCondition *NumberCondition `protobuf:"bytes,3,opt,name=left_number_condition,json=leftNumberCondition,oneof"`
}
type LogicalOperator_LeftNullCondition struct {
	LeftNullCondition *NullCondition `protobuf:"bytes,4,opt,name=left_null_condition,json=leftNullCondition,oneof"`
}
type LogicalOperator_RightOperator struct {
	RightOperator *LogicalOperator `protobuf:"bytes,5,opt,name=right_operator,json=rightOperator,oneof"`
}
type LogicalOperator_RightStringCondition struct {
	RightStringCondition *StringCondition `protobuf:"bytes,6,opt,name=right_string_condition,json=rightStringCondition,oneof"`
}
type LogicalOperator_RightNumberCondition struct {
	RightNumberCondition *NumberCondition `protobuf:"bytes,7,opt,name=right_number_condition,json=rightNumberCondition,oneof"`
}
type LogicalOperator_RightNullCondition struct {
	RightNullCondition *NullCondition `protobuf:"bytes,8,opt,name=right_null_condition,json=rightNullCondition,oneof"`
}

func (*LogicalOperator_LeftOperator) isLogicalOperator_Left()          {}
func (*LogicalOperator_LeftStringCondition) isLogicalOperator_Left()   {}
func (*LogicalOperator_LeftNumberCondition) isLogicalOperator_Left()   {}
func (*LogicalOperator_LeftNullCondition) isLogicalOperator_Left()     {}
func (*LogicalOperator_RightOperator) isLogicalOperator_Right()        {}
func (*LogicalOperator_RightStringCondition) isLogicalOperator_Right() {}
func (*LogicalOperator_RightNumberCondition) isLogicalOperator_Right() {}
func (*LogicalOperator_RightNullCondition) isLogicalOperator_Right()   {}

func (m *LogicalOperator) GetLeft() isLogicalOperator_Left {
	if m != nil {
		return m.Left
	}
	return nil
}
func (m *LogicalOperator) GetRight() isLogicalOperator_Right {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *LogicalOperator) GetLeftOperator() *LogicalOperator {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftOperator); ok {
		return x.LeftOperator
	}
	return nil
}

func (m *LogicalOperator) GetLeftStringCondition() *StringCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftStringCondition); ok {
		return x.LeftStringCondition
	}
	return nil
}

func (m *LogicalOperator) GetLeftNumberCondition() *NumberCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftNumberCondition); ok {
		return x.LeftNumberCondition
	}
	return nil
}

func (m *LogicalOperator) GetLeftNullCondition() *NullCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftNullCondition); ok {
		return x.LeftNullCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightOperator() *LogicalOperator {
	if x, ok := m.GetRight().(*LogicalOperator_RightOperator); ok {
		return x.RightOperator
	}
	return nil
}

func (m *LogicalOperator) GetRightStringCondition() *StringCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightStringCondition); ok {
		return x.RightStringCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightNumberCondition() *NumberCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightNumberCondition); ok {
		return x.RightNumberCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightNullCondition() *NullCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightNullCondition); ok {
		return x.RightNullCondition
	}
	return nil
}

func (m *LogicalOperator) GetType() LogicalOperator_Type {
	if m != nil {
		return m.Type
	}
	return LogicalOperator_AND
}

func (m *LogicalOperator) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LogicalOperator) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LogicalOperator_OneofMarshaler, _LogicalOperator_OneofUnmarshaler, _LogicalOperator_OneofSizer, []interface{}{
		(*LogicalOperator_LeftOperator)(nil),
		(*LogicalOperator_LeftStringCondition)(nil),
		(*LogicalOperator_LeftNumberCondition)(nil),
		(*LogicalOperator_LeftNullCondition)(nil),
		(*LogicalOperator_RightOperator)(nil),
		(*LogicalOperator_RightStringCondition)(nil),
		(*LogicalOperator_RightNumberCondition)(nil),
		(*LogicalOperator_RightNullCondition)(nil),
	}
}

func _LogicalOperator_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LogicalOperator)
	// left
	switch x := m.Left.(type) {
	case *LogicalOperator_LeftOperator:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftOperator); err != nil {
			return err
		}
	case *LogicalOperator_LeftStringCondition:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftStringCondition); err != nil {
			return err
		}
	case *LogicalOperator_LeftNumberCondition:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftNumberCondition); err != nil {
			return err
		}
	case *LogicalOperator_LeftNullCondition:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftNullCondition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LogicalOperator.Left has unexpected type %T", x)
	}
	// right
	switch x := m.Right.(type) {
	case *LogicalOperator_RightOperator:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightOperator); err != nil {
			return err
		}
	case *LogicalOperator_RightStringCondition:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightStringCondition); err != nil {
			return err
		}
	case *LogicalOperator_RightNumberCondition:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightNumberCondition); err != nil {
			return err
		}
	case *LogicalOperator_RightNullCondition:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightNullCondition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LogicalOperator.Right has unexpected type %T", x)
	}
	return nil
}

func _LogicalOperator_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LogicalOperator)
	switch tag {
	case 1: // left.left_operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalOperator)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftOperator{msg}
		return true, err
	case 2: // left.left_string_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftStringCondition{msg}
		return true, err
	case 3: // left.left_number_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftNumberCondition{msg}
		return true, err
	case 4: // left.left_null_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NullCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftNullCondition{msg}
		return true, err
	case 5: // right.right_operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalOperator)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightOperator{msg}
		return true, err
	case 6: // right.right_string_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightStringCondition{msg}
		return true, err
	case 7: // right.right_number_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightNumberCondition{msg}
		return true, err
	case 8: // right.right_null_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NullCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightNullCondition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LogicalOperator_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LogicalOperator)
	// left
	switch x := m.Left.(type) {
	case *LogicalOperator_LeftOperator:
		s := proto.Size(x.LeftOperator)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftStringCondition:
		s := proto.Size(x.LeftStringCondition)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftNumberCondition:
		s := proto.Size(x.LeftNumberCondition)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftNullCondition:
		s := proto.Size(x.LeftNullCondition)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// right
	switch x := m.Right.(type) {
	case *LogicalOperator_RightOperator:
		s := proto.Size(x.RightOperator)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightStringCondition:
		s := proto.Size(x.RightStringCondition)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightNumberCondition:
		s := proto.Size(x.RightNumberCondition)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightNullCondition:
		s := proto.Size(x.RightNullCondition)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StringCondition represents a condition with a string literal, e.g. field == 'string'.
// field_path is a reference to a value of a resource.
// value is the string literal.
// type is a type of the condition.
// is_negative is set to true if the condition is negated.
type StringCondition struct {
	FieldPath  []string             `protobuf:"bytes,1,rep,name=field_path,json=fieldPath" json:"field_path,omitempty"`
	Value      string               `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Type       StringCondition_Type `protobuf:"varint,3,opt,name=type,enum=infoblox.api.StringCondition_Type" json:"type,omitempty"`
	IsNegative bool                 `protobuf:"varint,4,opt,name=is_negative,json=isNegative" json:"is_negative,omitempty"`
}

func (m *StringCondition) Reset()                    { *m = StringCondition{} }
func (m *StringCondition) String() string            { return proto.CompactTextString(m) }
func (*StringCondition) ProtoMessage()               {}
func (*StringCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *StringCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *StringCondition) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *StringCondition) GetType() StringCondition_Type {
	if m != nil {
		return m.Type
	}
	return StringCondition_EQ
}

func (m *StringCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// NumberCondition represents a condition with a number literal, e.g. field > 3.
// field_path is a reference to a value of a resource.
// value is the number literal.
// type is a type of the condition.
// is_negative is set to true if the condition is negated.
type NumberCondition struct {
	FieldPath  []string             `protobuf:"bytes,1,rep,name=field_path,json=fieldPath" json:"field_path,omitempty"`
	Value      float64              `protobuf:"fixed64,2,opt,name=value" json:"value,omitempty"`
	Type       NumberCondition_Type `protobuf:"varint,3,opt,name=type,enum=infoblox.api.NumberCondition_Type" json:"type,omitempty"`
	IsNegative bool                 `protobuf:"varint,4,opt,name=is_negative,json=isNegative" json:"is_negative,omitempty"`
}

func (m *NumberCondition) Reset()                    { *m = NumberCondition{} }
func (m *NumberCondition) String() string            { return proto.CompactTextString(m) }
func (*NumberCondition) ProtoMessage()               {}
func (*NumberCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NumberCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *NumberCondition) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *NumberCondition) GetType() NumberCondition_Type {
	if m != nil {
		return m.Type
	}
	return NumberCondition_EQ
}

func (m *NumberCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// NullCondition represents a condition with a null literal, e.g. field == null.
// field_path is a reference to a value of a resource.
// is_negative is set to true if the condition is negated.
type NullCondition struct {
	FieldPath  []string `protobuf:"bytes,1,rep,name=field_path,json=fieldPath" json:"field_path,omitempty"`
	IsNegative bool     `protobuf:"varint,2,opt,name=is_negative,json=isNegative" json:"is_negative,omitempty"`
}

func (m *NullCondition) Reset()                    { *m = NullCondition{} }
func (m *NullCondition) String() string            { return proto.CompactTextString(m) }
func (*NullCondition) ProtoMessage()               {}
func (*NullCondition) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *NullCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *NullCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// Pagination represents both server-driven and client-driven pagination request.
// Server-driven pagination is a model in which the server returns some
// amount of data along with an token indicating there is more data
// and where subsequent queries can get the next page of data.
// Client-driven pagination is a model in which rows are addressable by
// offset and page size (limit).
type Pagination struct {
	// The service-defined string used to identify a page of resources.
	// A null value indicates the first page.
	PageToken string `protobuf:"bytes,1,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// The integer index of the offset into a collection of resources.
	// If omitted or null the value is assumed to be "0".
	Offset int32 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	// The integer number of resources to be returned in the response.
	// The service may impose maximum value.
	// If omitted the service may impose a default value.
	Limit int32 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *Pagination) Reset()                    { *m = Pagination{} }
func (m *Pagination) String() string            { return proto.CompactTextString(m) }
func (*Pagination) ProtoMessage()               {}
func (*Pagination) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Pagination) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *Pagination) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Pagination) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// PageInfo represents both server-driven and client-driven pagination response.
// Server-driven pagination is a model in which the server returns some
// amount of data along with an token indicating there is more data
// and where subsequent queries can get the next page of data.
// Client-driven pagination is a model in which rows are addressable by
// offset and page size (limit).
type PageInfo struct {
	// The service response should contain a string to indicate
	// the next page of resources.
	// A null value indicates no more pages.
	PageToken string `protobuf:"bytes,1,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
	// The service may optionally include the total number of resources being paged.
	Size int32 `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	// The service may optionally include the offset of the next page of resources.
	// A null value indicates no more pages.
	Offset int32 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
}

func (m *PageInfo) Reset()                    { *m = PageInfo{} }
func (m *PageInfo) String() string            { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()               {}
func (*PageInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PageInfo) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *PageInfo) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *PageInfo) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func init() {
	proto.RegisterType((*SortCriteria)(nil), "infoblox.api.SortCriteria")
	proto.RegisterType((*Sorting)(nil), "infoblox.api.Sorting")
	proto.RegisterType((*FieldSelection)(nil), "infoblox.api.FieldSelection")
	proto.RegisterType((*Field)(nil), "infoblox.api.Field")
	proto.RegisterType((*Filtering)(nil), "infoblox.api.Filtering")
	proto.RegisterType((*LogicalOperator)(nil), "infoblox.api.LogicalOperator")
	proto.RegisterType((*StringCondition)(nil), "infoblox.api.StringCondition")
	proto.RegisterType((*NumberCondition)(nil), "infoblox.api.NumberCondition")
	proto.RegisterType((*NullCondition)(nil), "infoblox.api.NullCondition")
	proto.RegisterType((*Pagination)(nil), "infoblox.api.Pagination")
	proto.RegisterType((*PageInfo)(nil), "infoblox.api.PageInfo")
	proto.RegisterEnum("infoblox.api.SortCriteria_Order", SortCriteria_Order_name, SortCriteria_Order_value)
	proto.RegisterEnum("infoblox.api.LogicalOperator_Type", LogicalOperator_Type_name, LogicalOperator_Type_value)
	proto.RegisterEnum("infoblox.api.StringCondition_Type", StringCondition_Type_name, StringCondition_Type_value)
	proto.RegisterEnum("infoblox.api.NumberCondition_Type", NumberCondition_Type_name, NumberCondition_Type_value)
}

func init() {
	proto.RegisterFile("github.com/infobloxopen/atlas-app-toolkit/op/collection_operators.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 843 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x96, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x80, 0x4d, 0x59, 0x52, 0xac, 0x93, 0x3f, 0x8d, 0xc9, 0x3a, 0x2f, 0x43, 0x31, 0x43, 0x57,
	0xde, 0x45, 0x65, 0x34, 0x03, 0x8a, 0x62, 0xbd, 0x59, 0xe3, 0x38, 0xcd, 0x86, 0x34, 0xce, 0x68,
	0xf7, 0x62, 0xbb, 0x31, 0x68, 0x87, 0x56, 0x88, 0x28, 0xa4, 0x20, 0xd1, 0xc5, 0xbc, 0x47, 0x19,
	0x76, 0xb5, 0x07, 0xd8, 0x03, 0xec, 0x25, 0xf6, 0x4a, 0x03, 0x69, 0xc9, 0x93, 0xe5, 0xac, 0x89,
	0xdb, 0x2b, 0x89, 0x07, 0xe7, 0x7c, 0x3c, 0xe7, 0x93, 0x4c, 0x0b, 0xde, 0x44, 0x5c, 0xdd, 0xcc,
	0xc6, 0xe1, 0x44, 0xde, 0x75, 0xb8, 0x98, 0xca, 0x71, 0x2c, 0x7f, 0x95, 0x09, 0x13, 0x1d, 0xaa,
	0x62, 0x9a, 0x3d, 0xa3, 0x49, 0xf2, 0x4c, 0x49, 0x19, 0xdf, 0x72, 0xd5, 0x91, 0x49, 0x67, 0x22,
	0xe3, 0x98, 0x4d, 0x14, 0x97, 0x62, 0x24, 0x13, 0x96, 0x52, 0x25, 0xd3, 0x2c, 0x4c, 0x52, 0xa9,
	0x24, 0xde, 0x29, 0xaa, 0x43, 0x9a, 0xf0, 0x40, 0xc1, 0xce, 0x40, 0xa6, 0xaa, 0x9b, 0x72, 0xc5,
	0x52, 0x4e, 0xb1, 0x0f, 0x75, 0x45, 0xa3, 0x26, 0x6a, 0xa1, 0xb6, 0x47, 0xf4, 0x2d, 0x7e, 0x01,
	0x8e, 0x4c, 0xaf, 0x59, 0xda, 0xb4, 0x5a, 0xa8, 0xbd, 0x77, 0xdc, 0x0a, 0xcb, 0xf5, 0x61, 0xb9,
	0x38, 0xec, 0xeb, 0x3c, 0xb2, 0x48, 0x0f, 0x8e, 0xc0, 0x31, 0x6b, 0xbc, 0x05, 0xf5, 0xd7, 0x83,
	0xae, 0x5f, 0xc3, 0x0d, 0xb0, 0x4f, 0x7b, 0x83, 0xae, 0x8f, 0x82, 0x2e, 0x6c, 0xe9, 0x42, 0x2e,
	0x22, 0xfc, 0x12, 0xbc, 0x49, 0x5e, 0x9f, 0x35, 0x51, 0xab, 0xde, 0xde, 0x3e, 0x3e, 0xfa, 0xff,
	0x2d, 0xc8, 0x7f, 0xc9, 0xc1, 0x9f, 0x08, 0xf6, 0xce, 0x38, 0x8b, 0xaf, 0x07, 0x2c, 0x9f, 0x15,
	0x7f, 0x0f, 0xee, 0x54, 0x47, 0x0a, 0x52, 0x7b, 0x95, 0xb4, 0x9a, 0xbd, 0x58, 0x66, 0x3d, 0xa1,
	0xd2, 0x39, 0xc9, 0xeb, 0x8e, 0x2e, 0x61, 0xbb, 0x14, 0xd6, 0x3a, 0x6e, 0xd9, 0xbc, 0xd0, 0x71,
	0xcb, 0xe6, 0xf8, 0x1b, 0x70, 0xde, 0xd3, 0x78, 0xc6, 0x8c, 0x8e, 0xed, 0xe3, 0x83, 0x7b, 0x76,
	0x20, 0x8b, 0x8c, 0xef, 0xac, 0x97, 0x28, 0xf8, 0x03, 0x81, 0x63, 0x82, 0x18, 0x83, 0x2d, 0xe8,
	0x1d, 0xcb, 0x59, 0xe6, 0x1e, 0x3f, 0x07, 0x3b, 0x9b, 0x8d, 0xb3, 0xa6, 0x65, 0xba, 0x7d, 0x7a,
	0x0f, 0x2b, 0x1c, 0xcc, 0xc6, 0x79, 0x8b, 0x26, 0xf5, 0xe8, 0x02, 0xbc, 0x65, 0xe8, 0xd3, 0xdb,
	0xfb, 0xcb, 0x02, 0xef, 0x8c, 0xc7, 0xda, 0xa8, 0x88, 0xf0, 0x2b, 0x68, 0x14, 0x6f, 0x8b, 0x61,
	0xae, 0xb5, 0x74, 0x21, 0x23, 0x3e, 0xa1, 0x71, 0x3f, 0x4f, 0x3a, 0xaf, 0x91, 0x65, 0x01, 0xfe,
	0x11, 0xfc, 0x4c, 0x69, 0xcc, 0x68, 0x22, 0xc5, 0x35, 0xd7, 0x86, 0xf3, 0x26, 0x2a, 0x90, 0x81,
	0xc9, 0xea, 0x16, 0x49, 0xe7, 0x35, 0xb2, 0x9f, 0xad, 0x86, 0x34, 0x4b, 0xcc, 0xee, 0xc6, 0x2c,
	0x2d, 0xb1, 0xea, 0xf7, 0xb1, 0x2e, 0x4d, 0xd6, 0x0a, 0x4b, 0xac, 0x86, 0xf0, 0x29, 0xec, 0x89,
	0x59, 0x1c, 0x97, 0x48, 0xb6, 0x21, 0x7d, 0x55, 0x25, 0xc5, 0x71, 0x99, 0xb3, 0x2b, 0xca, 0x81,
	0x13, 0x17, 0xec, 0x54, 0x4a, 0x15, 0xfc, 0xee, 0xc2, 0x7e, 0xc5, 0x02, 0x3e, 0x85, 0xdd, 0x98,
	0x4d, 0xd5, 0x68, 0x53, 0x77, 0x3b, 0xba, 0x6a, 0x49, 0x19, 0xc0, 0xe7, 0x86, 0xf2, 0xb1, 0x12,
	0x0f, 0x74, 0x75, 0x25, 0xbc, 0x84, 0x7e, 0xac, 0x4d, 0x03, 0xad, 0x84, 0xf1, 0x5b, 0x38, 0xc8,
	0xa1, 0x9b, 0x6b, 0xfd, 0x6c, 0x01, 0x2c, 0x05, 0xf1, 0x19, 0xec, 0xa5, 0x3c, 0xba, 0x29, 0xf9,
	0x73, 0x1e, 0xe3, 0x0f, 0x91, 0x5d, 0x53, 0xb6, 0x14, 0xf8, 0x0e, 0x9e, 0x2c, 0x38, 0x6b, 0x06,
	0xdd, 0xc7, 0x18, 0x44, 0xe4, 0xd0, 0x94, 0x57, 0x15, 0x2e, 0xb1, 0x6b, 0x0e, 0xb7, 0x1e, 0xe3,
	0xb0, 0xc0, 0x56, 0x25, 0xf6, 0xe1, 0xb0, 0xc0, 0xae, 0x58, 0x6c, 0x3c, 0x6c, 0x11, 0x11, 0x9c,
	0x23, 0xcb, 0x1a, 0x5f, 0x80, 0xad, 0xe6, 0x09, 0x6b, 0x7a, 0xe6, 0x98, 0x0e, 0x3e, 0x28, 0x2f,
	0x1c, 0xce, 0x13, 0x46, 0x4c, 0x3e, 0xfe, 0x1a, 0xb6, 0x79, 0x36, 0x12, 0x2c, 0xa2, 0x8a, 0xbf,
	0x67, 0x4d, 0x68, 0xa1, 0x76, 0x83, 0x00, 0xcf, 0x2e, 0xf3, 0x48, 0xf0, 0x05, 0xd8, 0x3a, 0xdd,
	0x9c, 0xe3, 0x97, 0xa7, 0x7e, 0x0d, 0xbb, 0x60, 0xf5, 0x89, 0x8f, 0xf4, 0x6f, 0x42, 0x3f, 0xcd,
	0x93, 0x2d, 0x70, 0x4c, 0x3f, 0xc1, 0xdf, 0x08, 0xf6, 0xab, 0xfa, 0x9e, 0x02, 0x98, 0xa3, 0x75,
	0x94, 0x50, 0x75, 0x63, 0x8e, 0x65, 0x8f, 0x78, 0x26, 0x72, 0x45, 0xd5, 0x0d, 0x3e, 0x2c, 0x9f,
	0x57, 0x5e, 0x7e, 0x34, 0x2d, 0x67, 0xa9, 0xdf, 0x37, 0x4b, 0x65, 0x87, 0x0f, 0xcc, 0x62, 0xaf,
	0xcd, 0xf2, 0x65, 0x3e, 0x8b, 0x0b, 0x56, 0xef, 0x27, 0xbf, 0x86, 0x3d, 0x70, 0xde, 0xbe, 0x1e,
	0x76, 0xcf, 0x7d, 0x14, 0xfc, 0x83, 0x60, 0xbf, 0xfa, 0x90, 0x36, 0x69, 0x1e, 0x3d, 0xaa, 0xf9,
	0xca, 0x0e, 0x1b, 0x35, 0x1f, 0x56, 0x9a, 0x77, 0xc1, 0x7a, 0x33, 0xf4, 0x91, 0xb9, 0xf6, 0x7c,
	0x4b, 0x5f, 0x2f, 0x86, 0x7e, 0xdd, 0x5c, 0x7b, 0xbe, 0x1d, 0xf4, 0x61, 0x77, 0xf5, 0x15, 0x79,
	0x60, 0x9c, 0x4a, 0x03, 0xd6, 0x5a, 0x03, 0x3f, 0x03, 0x5c, 0xd1, 0x88, 0x0b, 0x5a, 0xd0, 0x12,
	0x1a, 0xb1, 0x91, 0x92, 0xb7, 0x4c, 0xe4, 0xff, 0x41, 0x9e, 0x8e, 0x0c, 0x75, 0x00, 0x3f, 0x01,
	0x57, 0x4e, 0xa7, 0x19, 0x53, 0x06, 0xe4, 0x90, 0x7c, 0xa5, 0xa5, 0xc5, 0xfc, 0x8e, 0x2b, 0xe3,
	0xc7, 0x21, 0x8b, 0x45, 0xf0, 0x0e, 0x1a, 0x57, 0x34, 0x62, 0x3f, 0x88, 0xa9, 0x7c, 0x08, 0x8c,
	0xc1, 0xce, 0xf8, 0x6f, 0x2c, 0xc7, 0x9a, 0xfb, 0xd2, 0x66, 0xf5, 0xf2, 0x66, 0x27, 0xcf, 0x7f,
	0xe9, 0x6c, 0xf2, 0xdd, 0xf4, 0x4a, 0x26, 0x63, 0xd7, 0x7c, 0x26, 0x7d, 0xfb, 0x6f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x9f, 0x77, 0x30, 0xfd, 0x71, 0x09, 0x00, 0x00,
}
