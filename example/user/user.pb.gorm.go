package user

import (
	context "context"
	fmt "fmt"
	gateway "github.com/infobloxopen/atlas-app-toolkit/gateway"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	resource "github.com/infobloxopen/atlas-app-toolkit/gorm/resource"
	auth "github.com/infobloxopen/protoc-gen-gorm/auth"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type UserORM struct {
	AccountID         string
	BillingAddress    *AddressORM `gorm:"foreignKey:BillingAddressId;references:Id"`
	BillingAddressId  *int64
	Birthday          *time.Time
	CompartmentID     string
	CreatedAt         *time.Time
	CreditCard        *CreditCardORM `gorm:"foreignKey:UserId;references:Id"`
	Department        *DepartmentORM `gorm:"foreignKey:UserId;references:Id"`
	Emails            []*EmailORM    `gorm:"foreignKey:UserId;references:Id"`
	ExternalUuid      *string        `gorm:"type:uuid"`
	Friends           []*UserORM     `gorm:"foreignKey:Id;references:Id;many2many:user_friends;joinForeignKey:UserId;joinReferences:FriendId"`
	Id                string         `gorm:"type:uuid;primaryKey"`
	Languages         []*LanguageORM `gorm:"foreignKey:Id;references:Id;many2many:user_languages;joinForeignKey:UserId;joinReferences:LanguageId"`
	Num               uint32
	ShippingAddress   *AddressORM `gorm:"foreignKey:ShippingAddressId;references:Id"`
	ShippingAddressId *int64
	Tasks             []*TaskORM `gorm:"foreignKey:UserId;references:Id" atlas:"position:Priority"`
	UpdatedAt         *time.Time
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Decode(&User{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.Birthday != nil {
		t := m.Birthday.AsTime()
		to.Birthday = &t
	}
	to.Num = m.Num
	if m.CreditCard != nil {
		tempCreditCard, err := m.CreditCard.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCard = &tempCreditCard
	}
	for _, v := range m.Emails {
		if v != nil {
			if tempEmails, cErr := v.ToORM(ctx); cErr == nil {
				to.Emails = append(to.Emails, &tempEmails)
			} else {
				return to, cErr
			}
		} else {
			to.Emails = append(to.Emails, nil)
		}
	}
	for _, v := range m.Tasks {
		if v != nil {
			if tempTasks, cErr := v.ToORM(ctx); cErr == nil {
				to.Tasks = append(to.Tasks, &tempTasks)
			} else {
				return to, cErr
			}
		} else {
			to.Tasks = append(to.Tasks, nil)
		}
	}
	if m.BillingAddress != nil {
		tempBillingAddress, err := m.BillingAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.BillingAddress = &tempBillingAddress
	}
	if m.ShippingAddress != nil {
		tempShippingAddress, err := m.ShippingAddress.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ShippingAddress = &tempShippingAddress
	}
	for _, v := range m.Languages {
		if v != nil {
			if tempLanguages, cErr := v.ToORM(ctx); cErr == nil {
				to.Languages = append(to.Languages, &tempLanguages)
			} else {
				return to, cErr
			}
		} else {
			to.Languages = append(to.Languages, nil)
		}
	}
	for _, v := range m.Friends {
		if v != nil {
			if tempFriends, cErr := v.ToORM(ctx); cErr == nil {
				to.Friends = append(to.Friends, &tempFriends)
			} else {
				return to, cErr
			}
		} else {
			to.Friends = append(to.Friends, nil)
		}
	}
	if m.ShippingAddressId != nil {
		if v, err := resource.DecodeInt64(&Address{}, m.ShippingAddressId); err != nil {
			return to, err
		} else {
			to.ShippingAddressId = &v
		}
	}
	if m.ExternalUuid != nil {
		if v, err := resource.Decode(nil, m.ExternalUuid); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ExternalUuid = &vv
		}
	}
	if m.Department != nil {
		tempDepartment, err := m.Department.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Department = &tempDepartment
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.CompartmentID = compartmentID
	for i, e := range to.Tasks {
		e.Priority = int64(i)
	}
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Encode(&User{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.Birthday != nil {
		to.Birthday = timestamppb.New(*m.Birthday)
	}
	to.Num = m.Num
	if m.CreditCard != nil {
		tempCreditCard, err := m.CreditCard.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.CreditCard = &tempCreditCard
	}
	for _, v := range m.Emails {
		if v != nil {
			if tempEmails, cErr := v.ToPB(ctx); cErr == nil {
				to.Emails = append(to.Emails, &tempEmails)
			} else {
				return to, cErr
			}
		} else {
			to.Emails = append(to.Emails, nil)
		}
	}
	for _, v := range m.Tasks {
		if v != nil {
			if tempTasks, cErr := v.ToPB(ctx); cErr == nil {
				to.Tasks = append(to.Tasks, &tempTasks)
			} else {
				return to, cErr
			}
		} else {
			to.Tasks = append(to.Tasks, nil)
		}
	}
	if m.BillingAddress != nil {
		tempBillingAddress, err := m.BillingAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.BillingAddress = &tempBillingAddress
	}
	if m.ShippingAddress != nil {
		tempShippingAddress, err := m.ShippingAddress.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ShippingAddress = &tempShippingAddress
	}
	for _, v := range m.Languages {
		if v != nil {
			if tempLanguages, cErr := v.ToPB(ctx); cErr == nil {
				to.Languages = append(to.Languages, &tempLanguages)
			} else {
				return to, cErr
			}
		} else {
			to.Languages = append(to.Languages, nil)
		}
	}
	for _, v := range m.Friends {
		if v != nil {
			if tempFriends, cErr := v.ToPB(ctx); cErr == nil {
				to.Friends = append(to.Friends, &tempFriends)
			} else {
				return to, cErr
			}
		} else {
			to.Friends = append(to.Friends, nil)
		}
	}
	if m.ShippingAddressId != nil {
		if v, err := resource.Encode(&Address{}, *m.ShippingAddressId); err != nil {
			return to, err
		} else {
			to.ShippingAddressId = v
		}
	}
	if m.ExternalUuid != nil {
		if v, err := resource.Encode(nil, *m.ExternalUuid); err != nil {
			return to, err
		} else {
			to.ExternalUuid = v
		}
	}
	if m.Department != nil {
		tempDepartment, err := m.Department.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Department = &tempDepartment
	}
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

type EmailORM struct {
	AccountID       string
	CompartmentID   string
	Email           string
	ExternalNotNull string `gorm:"type:uuid;not null"`
	Id              string `gorm:"type:uuid;primaryKey"`
	Subscribed      bool
	UserId          *string
}

// TableName overrides the default tablename generated by GORM
func (EmailORM) TableName() string {
	return "emails"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Email) ToORM(ctx context.Context) (EmailORM, error) {
	to := EmailORM{}
	var err error
	if prehook, ok := interface{}(m).(EmailWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Decode(&Email{}, m.Id); err != nil {
		return to, err
	} else if v != nil {
		to.Id = v.(string)
	}
	to.Email = m.Email
	to.Subscribed = m.Subscribed
	if m.UserId != nil {
		if v, err := resource.Decode(&User{}, m.UserId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.UserId = &vv
		}
	}
	if v, err := resource.Decode(nil, m.ExternalNotNull); err != nil {
		return to, err
	} else if v != nil {
		to.ExternalNotNull = v.(string)
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.CompartmentID = compartmentID
	if posthook, ok := interface{}(m).(EmailWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmailORM) ToPB(ctx context.Context) (Email, error) {
	to := Email{}
	var err error
	if prehook, ok := interface{}(m).(EmailWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Encode(&Email{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Email = m.Email
	to.Subscribed = m.Subscribed
	if m.UserId != nil {
		if v, err := resource.Encode(&User{}, *m.UserId); err != nil {
			return to, err
		} else {
			to.UserId = v
		}
	}
	if v, err := resource.Encode(nil, m.ExternalNotNull); err != nil {
		return to, err
	} else {
		to.ExternalNotNull = v
	}
	if posthook, ok := interface{}(m).(EmailWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Email the arg will be the target, the caller the one being converted from

// EmailBeforeToORM called before default ToORM code
type EmailWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmailORM) error
}

// EmailAfterToORM called after default ToORM code
type EmailWithAfterToORM interface {
	AfterToORM(context.Context, *EmailORM) error
}

// EmailBeforeToPB called before default ToPB code
type EmailWithBeforeToPB interface {
	BeforeToPB(context.Context, *Email) error
}

// EmailAfterToPB called after default ToPB code
type EmailWithAfterToPB interface {
	AfterToPB(context.Context, *Email) error
}

type AddressORM struct {
	AccountID     string
	Address_1     string
	Address_2     *string
	CompartmentID string
	External      []byte  `gorm:"type:jsonb"`
	Id            int64   `gorm:"type:integer;primaryKey"`
	ImplicitFk    *string `gorm:"type:text"`
	Post          string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.DecodeInt64(&Address{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Address_1 = m.Address_1
	to.Address_2 = m.Address_2
	to.Post = m.Post
	if v, err := resource.DecodeBytes(nil, m.External); err != nil {
		return to, err
	} else {
		to.External = v
	}
	if m.ImplicitFk != nil {
		if v, err := resource.Decode(&Email{}, m.ImplicitFk); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.ImplicitFk = &vv
		}
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.CompartmentID = compartmentID
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Encode(&Address{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Address_1 = m.Address_1
	to.Address_2 = m.Address_2
	to.Post = m.Post
	if v, err := resource.Encode(nil, m.External); err != nil {
		return to, err
	} else {
		to.External = v
	}
	if m.ImplicitFk != nil {
		if v, err := resource.Encode(&Email{}, *m.ImplicitFk); err != nil {
			return to, err
		} else {
			to.ImplicitFk = v
		}
	}
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type LanguageORM struct {
	AccountID     string
	Code          string
	CompartmentID string
	ExternalInt   *int64 `gorm:"type:integer"`
	Id            int64  `gorm:"type:integer;primaryKey"`
	Name          string
}

// TableName overrides the default tablename generated by GORM
func (LanguageORM) TableName() string {
	return "languages"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Language) ToORM(ctx context.Context) (LanguageORM, error) {
	to := LanguageORM{}
	var err error
	if prehook, ok := interface{}(m).(LanguageWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.DecodeInt64(&Language{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Code = m.Code
	if m.ExternalInt != nil {
		if v, err := resource.DecodeInt64(nil, m.ExternalInt); err != nil {
			return to, err
		} else {
			to.ExternalInt = &v
		}
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.CompartmentID = compartmentID
	if posthook, ok := interface{}(m).(LanguageWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LanguageORM) ToPB(ctx context.Context) (Language, error) {
	to := Language{}
	var err error
	if prehook, ok := interface{}(m).(LanguageWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Encode(&Language{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	to.Name = m.Name
	to.Code = m.Code
	if m.ExternalInt != nil {
		if v, err := resource.Encode(nil, *m.ExternalInt); err != nil {
			return to, err
		} else {
			to.ExternalInt = v
		}
	}
	if posthook, ok := interface{}(m).(LanguageWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Language the arg will be the target, the caller the one being converted from

// LanguageBeforeToORM called before default ToORM code
type LanguageWithBeforeToORM interface {
	BeforeToORM(context.Context, *LanguageORM) error
}

// LanguageAfterToORM called after default ToORM code
type LanguageWithAfterToORM interface {
	AfterToORM(context.Context, *LanguageORM) error
}

// LanguageBeforeToPB called before default ToPB code
type LanguageWithBeforeToPB interface {
	BeforeToPB(context.Context, *Language) error
}

// LanguageAfterToPB called after default ToPB code
type LanguageWithAfterToPB interface {
	AfterToPB(context.Context, *Language) error
}

type CreditCardORM struct {
	AccountID     string
	CompartmentID string
	CreatedAt     *time.Time
	Id            int64 `gorm:"type:integer;primaryKey"`
	Number        string
	UpdatedAt     *time.Time
	UserId        *string
}

// TableName overrides the default tablename generated by GORM
func (CreditCardORM) TableName() string {
	return "credit_cards"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *CreditCard) ToORM(ctx context.Context) (CreditCardORM, error) {
	to := CreditCardORM{}
	var err error
	if prehook, ok := interface{}(m).(CreditCardWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.DecodeInt64(&CreditCard{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Number = m.Number
	if m.UserId != nil {
		if v, err := resource.Decode(&User{}, m.UserId); err != nil {
			return to, err
		} else if v != nil {
			vv := v.(string)
			to.UserId = &vv
		}
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.CompartmentID = compartmentID
	if posthook, ok := interface{}(m).(CreditCardWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CreditCardORM) ToPB(ctx context.Context) (CreditCard, error) {
	to := CreditCard{}
	var err error
	if prehook, ok := interface{}(m).(CreditCardWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	if v, err := resource.Encode(&CreditCard{}, m.Id); err != nil {
		return to, err
	} else {
		to.Id = v
	}
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Number = m.Number
	if m.UserId != nil {
		if v, err := resource.Encode(&User{}, *m.UserId); err != nil {
			return to, err
		} else {
			to.UserId = v
		}
	}
	if posthook, ok := interface{}(m).(CreditCardWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type CreditCard the arg will be the target, the caller the one being converted from

// CreditCardBeforeToORM called before default ToORM code
type CreditCardWithBeforeToORM interface {
	BeforeToORM(context.Context, *CreditCardORM) error
}

// CreditCardAfterToORM called after default ToORM code
type CreditCardWithAfterToORM interface {
	AfterToORM(context.Context, *CreditCardORM) error
}

// CreditCardBeforeToPB called before default ToPB code
type CreditCardWithBeforeToPB interface {
	BeforeToPB(context.Context, *CreditCard) error
}

// CreditCardAfterToPB called after default ToPB code
type CreditCardWithAfterToPB interface {
	AfterToPB(context.Context, *CreditCard) error
}

type TaskORM struct {
	AccountID     string
	CompartmentID string
	Description   string
	Id            *string
	Name          string
	Priority      int64
	UserId        string `gorm:"not null"`
}

// TableName overrides the default tablename generated by GORM
func (TaskORM) TableName() string {
	return "tasks"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Task) ToORM(ctx context.Context) (TaskORM, error) {
	to := TaskORM{}
	var err error
	if prehook, ok := interface{}(m).(TaskWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Priority = m.Priority
	to.Id = m.Id
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.CompartmentID = compartmentID
	if posthook, ok := interface{}(m).(TaskWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TaskORM) ToPB(ctx context.Context) (Task, error) {
	to := Task{}
	var err error
	if prehook, ok := interface{}(m).(TaskWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Description = m.Description
	to.Priority = m.Priority
	to.Id = m.Id
	if posthook, ok := interface{}(m).(TaskWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Task the arg will be the target, the caller the one being converted from

// TaskBeforeToORM called before default ToORM code
type TaskWithBeforeToORM interface {
	BeforeToORM(context.Context, *TaskORM) error
}

// TaskAfterToORM called after default ToORM code
type TaskWithAfterToORM interface {
	AfterToORM(context.Context, *TaskORM) error
}

// TaskBeforeToPB called before default ToPB code
type TaskWithBeforeToPB interface {
	BeforeToPB(context.Context, *Task) error
}

// TaskAfterToPB called after default ToPB code
type TaskWithAfterToPB interface {
	AfterToPB(context.Context, *Task) error
}

type DepartmentORM struct {
	Id     int64  `gorm:"primaryKey"`
	Name   string `gorm:"primaryKey"`
	UserId *string
}

// TableName overrides the default tablename generated by GORM
func (DepartmentORM) TableName() string {
	return "departments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Department) ToORM(ctx context.Context) (DepartmentORM, error) {
	to := DepartmentORM{}
	var err error
	if prehook, ok := interface{}(m).(DepartmentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Id = m.Id
	if posthook, ok := interface{}(m).(DepartmentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *DepartmentORM) ToPB(ctx context.Context) (Department, error) {
	to := Department{}
	var err error
	if prehook, ok := interface{}(m).(DepartmentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Name = m.Name
	to.Id = m.Id
	if posthook, ok := interface{}(m).(DepartmentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Department the arg will be the target, the caller the one being converted from

// DepartmentBeforeToORM called before default ToORM code
type DepartmentWithBeforeToORM interface {
	BeforeToORM(context.Context, *DepartmentORM) error
}

// DepartmentAfterToORM called after default ToORM code
type DepartmentWithAfterToORM interface {
	AfterToORM(context.Context, *DepartmentORM) error
}

// DepartmentBeforeToPB called before default ToPB code
type DepartmentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Department) error
}

// DepartmentAfterToPB called after default ToPB code
type DepartmentWithAfterToPB interface {
	AfterToPB(context.Context, *Department) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit("Emails").Preload("Emails").Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	accountId, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	compartmentId, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return err
	}
	if compartmentId != "" {
		err = db.Where("account_id = ? AND compartment_id like ?% AND id in (?)", accountId, compartmentId, keys).Delete(&UserORM{}).Error
		if err != nil {
			return err
		}
	} else {
		err = db.Where("account_id = ? AND id in (?)", accountId, keys).Delete(&UserORM{}).Error
		if err != nil {
			return err
		}
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if compartmentID != "" {
		db = db.Where(map[string]interface{}{"account_id": accountID, "compartment_id": compartmentID})
	} else {
		db = db.Where(map[string]interface{}{"account_id": accountID})
	}
	var count int64
	lockedRow := &UserORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterCreditCard := CreditCardORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterCreditCard.UserId = new(string)
	*filterCreditCard.UserId = ormObj.Id
	if err = db.Where(filterCreditCard).Delete(CreditCardORM{}).Error; err != nil {
		return nil, err
	}
	filterDepartment := DepartmentORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterDepartment.UserId = new(string)
	*filterDepartment.UserId = ormObj.Id
	if err = db.Where(filterDepartment).Delete(DepartmentORM{}).Error; err != nil {
		return nil, err
	}
	filterEmails := EmailORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterEmails.UserId = new(string)
	*filterEmails.UserId = ormObj.Id
	if err = db.Where(filterEmails).Delete(EmailORM{}).Error; err != nil {
		return nil, err
	}
	if err = db.Model(&ormObj).Association("Friends").Replace(ormObj.Friends); err != nil {
		return nil, err
	}
	ormObj.Friends = nil
	if err = db.Model(&ormObj).Association("Languages").Replace(ormObj.Languages); err != nil {
		return nil, err
	}
	ormObj.Languages = nil
	filterTasks := TaskORM{}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	filterTasks.UserId = ormObj.Id
	if err = db.Where(filterTasks).Delete(TaskORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit("Emails").Preload("Emails").Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedBirthday bool
	var updatedCreditCard bool
	var updatedBillingAddress bool
	var updatedShippingAddress bool
	var updatedDepartment bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedBirthday && strings.HasPrefix(f, prefix+"Birthday.") {
			if patcher.Birthday == nil {
				patchee.Birthday = nil
				continue
			}
			if patchee.Birthday == nil {
				patchee.Birthday = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"Birthday."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.Birthday, patchee.Birthday, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"Birthday" {
			updatedBirthday = true
			patchee.Birthday = patcher.Birthday
			continue
		}
		if f == prefix+"Age" {
			patchee.Age = patcher.Age
			continue
		}
		if f == prefix+"Num" {
			patchee.Num = patcher.Num
			continue
		}
		if !updatedCreditCard && strings.HasPrefix(f, prefix+"CreditCard.") {
			updatedCreditCard = true
			if patcher.CreditCard == nil {
				patchee.CreditCard = nil
				continue
			}
			if patchee.CreditCard == nil {
				patchee.CreditCard = &CreditCard{}
			}
			if o, err := DefaultApplyFieldMaskCreditCard(ctx, patchee.CreditCard, patcher.CreditCard, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"CreditCard.", db); err != nil {
				return nil, err
			} else {
				patchee.CreditCard = o
			}
			continue
		}
		if f == prefix+"CreditCard" {
			updatedCreditCard = true
			patchee.CreditCard = patcher.CreditCard
			continue
		}
		if f == prefix+"Emails" {
			patchee.Emails = patcher.Emails
			continue
		}
		if f == prefix+"Tasks" {
			patchee.Tasks = patcher.Tasks
			continue
		}
		if !updatedBillingAddress && strings.HasPrefix(f, prefix+"BillingAddress.") {
			updatedBillingAddress = true
			if patcher.BillingAddress == nil {
				patchee.BillingAddress = nil
				continue
			}
			if patchee.BillingAddress == nil {
				patchee.BillingAddress = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.BillingAddress, patcher.BillingAddress, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"BillingAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.BillingAddress = o
			}
			continue
		}
		if f == prefix+"BillingAddress" {
			updatedBillingAddress = true
			patchee.BillingAddress = patcher.BillingAddress
			continue
		}
		if !updatedShippingAddress && strings.HasPrefix(f, prefix+"ShippingAddress.") {
			updatedShippingAddress = true
			if patcher.ShippingAddress == nil {
				patchee.ShippingAddress = nil
				continue
			}
			if patchee.ShippingAddress == nil {
				patchee.ShippingAddress = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.ShippingAddress, patcher.ShippingAddress, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ShippingAddress.", db); err != nil {
				return nil, err
			} else {
				patchee.ShippingAddress = o
			}
			continue
		}
		if f == prefix+"ShippingAddress" {
			updatedShippingAddress = true
			patchee.ShippingAddress = patcher.ShippingAddress
			continue
		}
		if f == prefix+"Languages" {
			patchee.Languages = patcher.Languages
			continue
		}
		if f == prefix+"Friends" {
			patchee.Friends = patcher.Friends
			continue
		}
		if f == prefix+"ShippingAddressId" {
			patchee.ShippingAddressId = patcher.ShippingAddressId
			continue
		}
		if f == prefix+"ExternalUuid" {
			patchee.ExternalUuid = patcher.ExternalUuid
			continue
		}
		if !updatedDepartment && strings.HasPrefix(f, prefix+"Department.") {
			updatedDepartment = true
			if patcher.Department == nil {
				patchee.Department = nil
				continue
			}
			if patchee.Department == nil {
				patchee.Department = &Department{}
			}
			if o, err := DefaultApplyFieldMaskDepartment(ctx, patchee.Department, patcher.Department, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Department.", db); err != nil {
				return nil, err
			} else {
				patchee.Department = o
			}
			continue
		}
		if f == prefix+"Department" {
			updatedDepartment = true
			patchee.Department = patcher.Department
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}

// DefaultCreateEmail executes a basic gorm create call
func DefaultCreateEmail(ctx context.Context, in *Email, db *gorm.DB) (*Email, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmailORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadEmail(ctx context.Context, in *Email, db *gorm.DB) (*Email, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmailORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmailORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmailORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteEmail(ctx context.Context, in *Email, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmailORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmailORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteEmailSet(ctx context.Context, in []*Email, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmailORM{})).(EmailORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	accountId, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	compartmentId, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return err
	}
	if compartmentId != "" {
		err = db.Where("account_id = ? AND compartment_id like ?% AND id in (?)", accountId, compartmentId, keys).Delete(&EmailORM{}).Error
		if err != nil {
			return err
		}
	} else {
		err = db.Where("account_id = ? AND id in (?)", accountId, keys).Delete(&EmailORM{}).Error
		if err != nil {
			return err
		}
	}
	if hook, ok := (interface{}(&EmailORM{})).(EmailORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmailORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Email, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Email, *gorm.DB) error
}

// DefaultStrictUpdateEmail clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmail(ctx context.Context, in *Email, db *gorm.DB) (*Email, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmail")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if compartmentID != "" {
		db = db.Where(map[string]interface{}{"account_id": accountID, "compartment_id": compartmentID})
	} else {
		db = db.Where(map[string]interface{}{"account_id": accountID})
	}
	var count int64
	lockedRow := &EmailORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type EmailORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchEmail executes a basic gorm update call with patch behavior
func DefaultPatchEmail(ctx context.Context, in *Email, updateMask *field_mask.FieldMask, db *gorm.DB) (*Email, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Email
	var err error
	if hook, ok := interface{}(&pbObj).(EmailWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmail(ctx, &Email{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmailWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmail(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmailWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmail(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmailWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmailWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Email, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmailWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Email, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmailWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Email, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type EmailWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Email, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetEmail executes a bulk gorm update call with patch behavior
func DefaultPatchSetEmail(ctx context.Context, objects []*Email, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Email, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Email, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchEmail(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskEmail patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmail(ctx context.Context, patchee *Email, patcher *Email, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Email, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Subscribed" {
			patchee.Subscribed = patcher.Subscribed
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if f == prefix+"ExternalNotNull" {
			patchee.ExternalNotNull = patcher.ExternalNotNull
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmail executes a gorm list call
func DefaultListEmail(ctx context.Context, db *gorm.DB) ([]*Email, error) {
	in := Email{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmailORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmailORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Email{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmailORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type EmailORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]EmailORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	accountId, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	compartmentId, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return err
	}
	if compartmentId != "" {
		err = db.Where("account_id = ? AND compartment_id like ?% AND id in (?)", accountId, compartmentId, keys).Delete(&AddressORM{}).Error
		if err != nil {
			return err
		}
	} else {
		err = db.Where("account_id = ? AND id in (?)", accountId, keys).Delete(&AddressORM{}).Error
		if err != nil {
			return err
		}
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if compartmentID != "" {
		db = db.Where(map[string]interface{}{"account_id": accountID, "compartment_id": compartmentID})
	} else {
		db = db.Where(map[string]interface{}{"account_id": accountID})
	}
	var count int64
	lockedRow := &AddressORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address_1" {
			patchee.Address_1 = patcher.Address_1
			continue
		}
		if f == prefix+"Address_2" {
			patchee.Address_2 = patcher.Address_2
			continue
		}
		if f == prefix+"Post" {
			patchee.Post = patcher.Post
			continue
		}
		if f == prefix+"External" {
			patchee.External = patcher.External
			continue
		}
		if f == prefix+"ImplicitFk" {
			patchee.ImplicitFk = patcher.ImplicitFk
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateLanguage executes a basic gorm create call
func DefaultCreateLanguage(ctx context.Context, in *Language, db *gorm.DB) (*Language, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LanguageORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLanguage(ctx context.Context, in *Language, db *gorm.DB) (*Language, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LanguageORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LanguageORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LanguageORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLanguage(ctx context.Context, in *Language, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LanguageORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LanguageORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLanguageSet(ctx context.Context, in []*Language, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LanguageORM{})).(LanguageORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	accountId, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	compartmentId, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return err
	}
	if compartmentId != "" {
		err = db.Where("account_id = ? AND compartment_id like ?% AND id in (?)", accountId, compartmentId, keys).Delete(&LanguageORM{}).Error
		if err != nil {
			return err
		}
	} else {
		err = db.Where("account_id = ? AND id in (?)", accountId, keys).Delete(&LanguageORM{}).Error
		if err != nil {
			return err
		}
	}
	if hook, ok := (interface{}(&LanguageORM{})).(LanguageORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LanguageORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Language, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Language, *gorm.DB) error
}

// DefaultStrictUpdateLanguage clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLanguage(ctx context.Context, in *Language, db *gorm.DB) (*Language, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLanguage")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if compartmentID != "" {
		db = db.Where(map[string]interface{}{"account_id": accountID, "compartment_id": compartmentID})
	} else {
		db = db.Where(map[string]interface{}{"account_id": accountID})
	}
	var count int64
	lockedRow := &LanguageORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type LanguageORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLanguage executes a basic gorm update call with patch behavior
func DefaultPatchLanguage(ctx context.Context, in *Language, updateMask *field_mask.FieldMask, db *gorm.DB) (*Language, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Language
	var err error
	if hook, ok := interface{}(&pbObj).(LanguageWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLanguage(ctx, &Language{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LanguageWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLanguage(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LanguageWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLanguage(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LanguageWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LanguageWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Language, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LanguageWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Language, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LanguageWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Language, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LanguageWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Language, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLanguage executes a bulk gorm update call with patch behavior
func DefaultPatchSetLanguage(ctx context.Context, objects []*Language, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Language, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Language, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLanguage(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLanguage patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLanguage(ctx context.Context, patchee *Language, patcher *Language, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Language, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
		if f == prefix+"ExternalInt" {
			patchee.ExternalInt = patcher.ExternalInt
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLanguage executes a gorm list call
func DefaultListLanguage(ctx context.Context, db *gorm.DB) ([]*Language, error) {
	in := Language{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LanguageORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LanguageORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Language{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LanguageORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LanguageORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LanguageORM) error
}

// DefaultCreateCreditCard executes a basic gorm create call
func DefaultCreateCreditCard(ctx context.Context, in *CreditCard, db *gorm.DB) (*CreditCard, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CreditCardORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadCreditCard(ctx context.Context, in *CreditCard, db *gorm.DB) (*CreditCard, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CreditCardORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CreditCardORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CreditCardORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditCard(ctx context.Context, in *CreditCard, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CreditCardORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CreditCardORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteCreditCardSet(ctx context.Context, in []*CreditCard, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CreditCardORM{})).(CreditCardORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	accountId, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	compartmentId, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return err
	}
	if compartmentId != "" {
		err = db.Where("account_id = ? AND compartment_id like ?% AND id in (?)", accountId, compartmentId, keys).Delete(&CreditCardORM{}).Error
		if err != nil {
			return err
		}
	} else {
		err = db.Where("account_id = ? AND id in (?)", accountId, keys).Delete(&CreditCardORM{}).Error
		if err != nil {
			return err
		}
	}
	if hook, ok := (interface{}(&CreditCardORM{})).(CreditCardORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CreditCardORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*CreditCard, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*CreditCard, *gorm.DB) error
}

// DefaultStrictUpdateCreditCard clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCreditCard(ctx context.Context, in *CreditCard, db *gorm.DB) (*CreditCard, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCreditCard")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if compartmentID != "" {
		db = db.Where(map[string]interface{}{"account_id": accountID, "compartment_id": compartmentID})
	} else {
		db = db.Where(map[string]interface{}{"account_id": accountID})
	}
	var count int64
	lockedRow := &CreditCardORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type CreditCardORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchCreditCard executes a basic gorm update call with patch behavior
func DefaultPatchCreditCard(ctx context.Context, in *CreditCard, updateMask *field_mask.FieldMask, db *gorm.DB) (*CreditCard, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj CreditCard
	var err error
	if hook, ok := interface{}(&pbObj).(CreditCardWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCreditCard(ctx, &CreditCard{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CreditCardWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCreditCard(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CreditCardWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCreditCard(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CreditCardWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CreditCardWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *CreditCard, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditCardWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *CreditCard, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditCardWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *CreditCard, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type CreditCardWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *CreditCard, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetCreditCard executes a bulk gorm update call with patch behavior
func DefaultPatchSetCreditCard(ctx context.Context, objects []*CreditCard, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*CreditCard, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*CreditCard, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchCreditCard(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskCreditCard patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCreditCard(ctx context.Context, patchee *CreditCard, patcher *CreditCard, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*CreditCard, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Number" {
			patchee.Number = patcher.Number
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCreditCard executes a gorm list call
func DefaultListCreditCard(ctx context.Context, db *gorm.DB) ([]*CreditCard, error) {
	in := CreditCard{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CreditCardORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CreditCardORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*CreditCard{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CreditCardORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type CreditCardORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]CreditCardORM) error
}

// DefaultCreateTask executes a basic gorm create call
func DefaultCreateTask(ctx context.Context, in *Task, db *gorm.DB) (*Task, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TaskORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTask(ctx context.Context, in *Task, db *gorm.DB) (*Task, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == nil || *ormObj.Id == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TaskORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TaskORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TaskORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTask(ctx context.Context, in *Task, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == nil || *ormObj.Id == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TaskORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TaskORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTaskSet(ctx context.Context, in []*Task, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []*string{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == nil || *ormObj.Id == "" {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TaskORM{})).(TaskORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	accountId, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	compartmentId, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return err
	}
	if compartmentId != "" {
		err = db.Where("account_id = ? AND compartment_id like ?% AND id in (?)", accountId, compartmentId, keys).Delete(&TaskORM{}).Error
		if err != nil {
			return err
		}
	} else {
		err = db.Where("account_id = ? AND id in (?)", accountId, keys).Delete(&TaskORM{}).Error
		if err != nil {
			return err
		}
	}
	if hook, ok := (interface{}(&TaskORM{})).(TaskORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TaskORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Task, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Task, *gorm.DB) error
}

// DefaultStrictUpdateTask clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTask(ctx context.Context, in *Task, db *gorm.DB) (*Task, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTask")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	compartmentID, err := auth.GetCompartmentID(ctx, nil)
	if err != nil {
		return nil, err
	}
	if compartmentID != "" {
		db = db.Where(map[string]interface{}{"account_id": accountID, "compartment_id": compartmentID})
	} else {
		db = db.Where(map[string]interface{}{"account_id": accountID})
	}
	var count int64
	lockedRow := &TaskORM{}
	count = db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow).RowsAffected
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	if count == 0 {
		err = gateway.SetCreated(ctx, "")
	}
	return &pbResponse, err
}

type TaskORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTask executes a basic gorm update call with patch behavior
func DefaultPatchTask(ctx context.Context, in *Task, updateMask *field_mask.FieldMask, db *gorm.DB) (*Task, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Task
	var err error
	if hook, ok := interface{}(&pbObj).(TaskWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTask(ctx, &Task{Id: in.Id}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TaskWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTask(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TaskWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTask(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TaskWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TaskWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Task, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaskWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Task, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaskWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Task, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TaskWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Task, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTask executes a bulk gorm update call with patch behavior
func DefaultPatchSetTask(ctx context.Context, objects []*Task, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Task, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Task, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTask(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTask patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTask(ctx context.Context, patchee *Task, patcher *Task, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Task, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"Priority" {
			patchee.Priority = patcher.Priority
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTask executes a gorm list call
func DefaultListTask(ctx context.Context, db *gorm.DB) ([]*Task, error) {
	in := Task{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TaskORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TaskORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Task{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TaskORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TaskORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TaskORM) error
}

// DefaultCreateDepartment executes a basic gorm create call
func DefaultCreateDepartment(ctx context.Context, in *Department, db *gorm.DB) (*Department, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type DepartmentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadDepartment(ctx context.Context, in *Department, db *gorm.DB) (*Department, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if ormObj.Name == "" {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := DepartmentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(DepartmentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type DepartmentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteDepartment(ctx context.Context, in *Department, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if ormObj.Name == "" {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&DepartmentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type DepartmentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskDepartment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskDepartment(ctx context.Context, patchee *Department, patcher *Department, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Department, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListDepartment executes a gorm list call
func DefaultListDepartment(ctx context.Context, db *gorm.DB) ([]*Department, error) {
	in := Department{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id, name")
	ormResponse := []DepartmentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(DepartmentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Department{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type DepartmentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type DepartmentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]DepartmentORM) error
}
