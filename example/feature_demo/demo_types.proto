syntax = "proto3";

package example;

import "google/protobuf/wrappers.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";

import "options/gorm.proto";
import "types/types.proto";

import "feature_demo/demo_service.proto";
import "user/user.proto";
import "postgres_arrays/postgres_arrays.proto";
import "feature_demo/demo_multi_file.proto";

option go_package = "github.com/infobloxopen/protoc-gen-gorm/example/feature_demo;example";

// test_types is a message that includes a representative sample of the
// available types
message TestTypes {
  // The 'ormable' option flags this for converter autogeneration
  // The table option allows for overriding the default table name 'test_types'
  // Two 'included' postgres string arrays demonstrate importing a package for
  // a special type needed within a gorm object
  option (gorm.opts) = {
    ormable:true,
    table: "smorgasbord",
    include: [
    {type: "StringArray", name: "array", package:"github.com/lib/pq"},
    {type: "StringArray", name: "array2", package:"github.com/lib/pq"}
    ]};
  // the (gorm.field).drop option allows for setting a field to be API only
  string api_only_string = 1 [(gorm.field).drop = true];
  // repeated raw types are currently unsupported, so this field will be dropped
  // at the ORM level
  repeated int32 numbers = 2;
  // a StringValue represents a Nullable string
  google.protobuf.StringValue optional_string = 3;
  // enums are mapped to the their underlying numeric value in the db.
  // This is practical from an API perspective, but tougher for debugging.
  // Strings with validation constraints can be used instead if desired
  enum status{
    UNKNOWN = 0;
    GOOD = 1;
    BAD = 2;
  }
  status becomes_int = 4;
  // The Empty type serves no purpose outside of rpc calls and is dropped
  // automatically from objects
  google.protobuf.Empty nothingness = 5;
  // The UUID custom type should act like a StringValue at the API level, but is
  // automatically converted to and from a uuid.UUID (github.com/satori/go.uuid)
  gorm.types.UUID uuid = 6;
  // Timestamps convert to golang's time.Time type, and created_at and
  // updated_at values are automatically filled by GORM
  google.protobuf.Timestamp created_at = 7;
  // Duration convert to golang's time.Duration type.
  google.protobuf.Duration duration = 8;
  // This represents a foreign key to the 'type_with_id' type for associations
  // This could be hidden from the API (or soon autogenerated).
  uint32 type_with_id_id = 9;
  // This is an arbitrary JSON string that is marshalled and unmarshalled
  // specially in grpc-gateway as a JSON object
  gorm.types.JSONValue json_field = 10;
  // The UUIDValue custom type should act like a StringValue at the API level, but is
  // automatically converted to and from a *uuid.UUID (github.com/satori/go.uuid)
  gorm.types.UUIDValue nullable_uuid = 11;
  // The TimeOnly should act as uint32 value at business layer, but is automatically
  // converted to/from string at API and ORM level
  gorm.types.TimeOnly time_only = 12;
  gorm.types.BigInt bigint = 13;
  // Repeated non-ormable objects are currently treated as single entity for
  // purposes of an object's field masking
  repeated gorm.types.JSONValue several_values = 14;
}

// TypeWithID demonstrates some basic association behavior
message TypeWithID {
  // Again we use the 'ormable' option, but also include an extra field
  // using the 'include' option. Any number of fields can be defined this way
  // to be visible on the ORM side, but hidden from the API. This is generally
  // useful to aggregate values from the database into API fields
  option (gorm.opts) = {
    ormable: true,
    include: [
      {type: "int32", name: "secret_int", tag: {ignore: true}},
      {type: "[]*JoinTable", name: "multi_account_types", tag: {foreignkey: "TypeWithIDID"}}
      ]
    };
  // any field named 'id' is assumed by gorm to be the primary key for the
  // object.
  uint32 id = 1;
  // The field option also allows arbitrary tag setting, such as informing
  // gorm of a primary key, different column names or different types in the db
  string ip = 2 [(gorm.field) = {tag: {column: "ip_addr"}}];
  // A default has-many relationship, will error on generation if no FK field,
  // convention {typename}_id, is present. These FK fields will be automatically
  // populated on create and update.
  repeated TestTypes things = 3;
  // A default has-one relationship, will error as above
  TestTypes a_nested_object = 4;
  // An in-package and cross-package imported type (in-package can use any
  // association type, cross-package is limited to belongs_to and many_to_many)
  example.IntPoint point = 5 [(gorm.field).belongs_to = {}];
  user.User user = 6 [(gorm.field).belongs_to = {}];
  gorm.types.InetValue address = 7;
  repeated uint32 multiaccount_type_ids = 8 [(gorm.field).drop = true];
  APIOnlyType synthetic_field = 9;
  float tag_test = 10 [(gorm.field).tag = {type: "float" , precision: 6}];
  string tag_size_test = 11 [(gorm.field).tag = {size: 512}];
  google.protobuf.FloatValue float_field = 12;
  google.protobuf.DoubleValue double_field = 13;
  // Limited support for DB type 'time', implemented via strings (string -> DB && DB -> string)
  gorm.types.TimeOnly time_only = 14;
  google.protobuf.Timestamp deleted_at = 15;
  bytes metadata = 16;
}

// MultiaccountTypeWithID demonstrates the generated multi-account support
message MultiaccountTypeWithID {
  // here we use the multi-account option to generate auth integration in
  // the ORM layer, and an assumed "account_id" column
  option (gorm.opts) = {
    ormable: true,
    multi_account: true
    multi_compartment: true
  };
  uint64 id = 1;
  string some_field = 2;
}

message MultiaccountTypeWithoutID {
  // here no id field is given, but it is still a multitenant type
  // this is a bad pattern, as there is no way to uniquely identify objects
  // in the DB, so R/U/D behavior is not well defined
  option (gorm.opts) = {
    ormable: true,
    multi_account: true
    multi_compartment: true
  };
  string some_field = 1;
}

message APIOnlyType {
  // here the ormable flag is not used, so nothing will be generated for this
  // object at the ORM level, and when this type is used as a field or
  // repeated field in another message that field will be dropped in the Orm
  // model, and would have to be set by hook
  string contents = 1;
}


message PrimaryUUIDType {
  option (gorm.opts) = {
    ormable: true,
  };
  gorm.types.UUIDValue id = 1;
  ExternalChild child = 2;
}

message PrimaryStringType {
  option (gorm.opts) = {
    ormable: true,
  };
  string id = 1;
  ExternalChild child = 2;
}

message TestTag {
  option (gorm.opts) = {
    ormable: true,
  };
  string id = 1;
  TestTagAssociation testTagAssoc = 2 [(gorm.field).has_one.preload = false];
}

// replace by default
message TestAssocHandlerDefault {
  option (gorm.opts) = {
    ormable: true,
  };
  string id = 1;
  repeated TestTagAssociation testTagAssoc = 2 [(gorm.field).has_many = {
    preload: false
  }];
}
message TestAssocHandlerReplace {
  option (gorm.opts) = {
    ormable: true,
  };
  string id = 1;
  repeated TestTagAssociation testTagAssoc = 2 [(gorm.field).has_many = {
    replace: true
    preload: false
  }];
}

message TestAssocHandlerClear {
  option (gorm.opts) = {
    ormable: true,
  };
  string id = 1;
  repeated TestTagAssociation testTagAssoc = 2 [(gorm.field).has_many = {
    clear: true
    preload: false
  }];
}
message TestAssocHandlerAppend {
  option (gorm.opts) = {
    ormable: true,
  };
  string id = 1;
  repeated TestTagAssociation testTagAssoc = 2 [(gorm.field).has_many = {
    append: true
    preload: false
  }];
}

message TestTagAssociation {
  option (gorm.opts) = {
    ormable: true,
  };
  string some_field = 1;
}

message PrimaryIncluded {
    option(gorm.opts) = {
      ormable: true,
      include: [
        {type: "UUID", name: "id"}]
    };
    ExternalChild child = 1;
}
